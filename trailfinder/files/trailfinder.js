// Generated by CoffeeScript 1.3.3
(function() {
  var ActivationFilterControl, DataSource, FLICKR_KEY, Filter, FilterControl, FlickrDataSource, IncludeFilterControl, InfoWindow, Map, Marker, MatchFilterControl, PostTypeControl, blank_location, __duplicate_marker_map, __filter_index, __id_marker_map, __marker_polylines, __type_marker_map,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  FLICKR_KEY = "9e3fc95c3ecc55351d6b4cc5fe15bba7";

  __duplicate_marker_map = {};

  __type_marker_map = {};

  __id_marker_map = {};

  InfoWindow = (function(_super) {

    __extends(InfoWindow, _super);

    function InfoWindow() {
      return InfoWindow.__super__.constructor.apply(this, arguments);
    }

    InfoWindow.prototype.marker_content = {
      "default": "<div class=\"info-single\">\n  <div class=\"info\">\n    <h3 style=\"background:url('{{marker_icon}}') no-repeat left;\">\n      <a href=\"{{url}}\" {{#target}}target=\"{{target}}\"{{/target}}>{{post_title}}</a>\n    </h3>\n\n    <a class=\"tnt-directions\" href=\"{{url}}\"\n     {{#target}}target=\"{{target}}\"{{/target}}\n       > More Info\n    </a>\n  </div>\n</div>",
      trailhead: "<div class=\"info-single\">\n  <div class=\"info\">\n    <h3 style=\"background:url('{{marker_icon}}') no-repeat left;\">\n      {{post_title}}\n    </h3>\n\n    <a class=\"tnt-directions\" onclick=\"return tnt_directions.bind(this)();\" data-latitude=\"{{latitude}}\" data-longitude=\"{{longitude}}\">\n      Get Directions\n    </a>\n  </div>\n</div>"
    };

    InfoWindow.prototype.multi_marker_content = "<div class=\"info-container\">\n  {{#collection}}\n    {{{marker_template}}}\n  {{/collection}} \n</div>";

    InfoWindow.prototype.tooltip_content = "<div class=\"tooltip\">\n  {{post_title}}\n</div>";

    InfoWindow.prototype.open_multiple = function(markers) {
      var collection_json, marker, marker_template, _bubble, _i, _len;
      jQuery('html, body').animate({
        scrollTop: jQuery("#map_canvas").offset().top - 100
      }, 500);
      _bubble = this;
      marker_template = function() {
        var template;
        template = _bubble.marker_content[this.post_type] || _bubble.marker_content["default"];
        return Mustache.render(template, this);
      };
      collection_json = [];
      for (_i = 0, _len = markers.length; _i < _len; _i++) {
        marker = markers[_i];
        collection_json.push(jQuery(marker).data("marker_data"));
      }
      this.setContent(Mustache.render(this.multi_marker_content, {
        collection: collection_json,
        marker_template: marker_template
      }));
      return this.open(_map.map, markers[0]);
    };

    InfoWindow.prototype.open_single = function(marker) {
      this.open_multiple([marker]);
      return this.open(_map.map, marker);
    };

    InfoWindow.prototype.open_tooltip = function(marker) {
      var _this = this;
      this.setContent(Mustache.render(this.tooltip_content, jQuery(marker).data("marker_data")));
      jQuery(this.content_).unbind("click.tooltip");
      jQuery(this.content_).bind("click.tooltip", function() {
        _this.close();
        return Marker.click(marker);
      });
      return this.open(_map.map, marker);
    };

    return InfoWindow;

  })(InfoBubble);

  __marker_polylines = {};

  Marker = {
    map_set: function(map, marker) {
      var point, points, route, _i, _len, _ref,
        _this = this;
      if (!_map.options.routes) {
        return;
      }
      if (jQuery(marker).data("marker_data").route) {
        if (map) {
          if (jQuery(marker).data("route")) {
            route = jQuery(marker).data("route");
          } else {
            points = [];
            _ref = JSON.parse(jQuery(marker).data("marker_data").route[0]);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              point = _ref[_i];
              points.push(new google.maps.LatLng(point[0], point[1]));
            }
            route = new google.maps.Polyline({
              geodesic: true,
              clickable: true,
              editable: false,
              path: points,
              strokeColor: "#F42F0D",
              strokeOpacity: 0.8
            });
            google.maps.event.addListener(route, "click", (function(opts) {
              return Marker.click(marker);
            }));
            jQuery(marker).data("route", route);
          }
          return route.setMap(map);
        } else {
          jQuery(marker).data("route").setMap(null);
          return jQuery(marker).data("route", null);
        }
      }
    },
    focus: function(map, marker) {
      var acres, circle, dfd, dfds, geocoder, geocoder_bounds, meters, search_bounds, _parse_geocoder_results;
      if (jQuery(marker).data("marker_data").post_type === "park") {
        geocoder = new google.maps.Geocoder();
        try {
          acres = parseInt(jQuery(marker).data("marker_data").acres[0]);
          if (acres) {
            meters = Math.sqrt(acres) * 63;
          } else {
            meters = 1000;
          }
        } catch (error) {
          meters = 1000;
        }
        circle = new google.maps.Circle({
          radius: meters,
          center: marker.position
        });
        search_bounds = circle.getBounds();
        geocoder_bounds = null;
        dfds = [];
        _parse_geocoder_results = function(results) {
          var result, type, _i, _j, _len, _len1, _ref;
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            result = results[_i];
            _ref = result.types;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              type = _ref[_j];
              if (type === "park") {
                geocoder_bounds = result.geometry.viewport;
                return;
              }
            }
          }
        };
        dfd = jQuery.Deferred();
        (function(dfd) {
          dfds.push(dfd.promise());
          return geocoder.geocode({
            latLng: marker.position,
            bounds: search_bounds
          }, function(results, status) {
            if (status === "OK") {
              _parse_geocoder_results(results);
            }
            return dfd.resolve();
          });
        })(dfd);
        dfd = jQuery.Deferred();
        (function(dfd) {
          dfds.push(dfd.promise());
          return geocoder.geocode({
            address: "" + (jQuery(marker).data("marker_data").post_title) + ", CA",
            bounds: search_bounds
          }, function(results, status) {
            if (status === "OK") {
              _parse_geocoder_results(results);
            }
            return dfd.resolve();
          });
        })(dfd);
        return jQuery.when.apply(this, dfds).then(function() {
          var bounds;
          if (geocoder_bounds) {
            bounds = geocoder_bounds;
          } else {
            bounds = search_bounds;
          }
          return map.map.fitBounds(bounds);
        });
      }
    },
    mouseover: function(marker) {
      var hover_window;
      hover_window = jQuery(_map.map).data("hover-window");
      return hover_window.open_tooltip(marker);
    },
    mouseout: function(marker) {
      var hover_window;
      hover_window = jQuery(_map.map).data("hover-window");
      return hover_window.close();
    },
    click: function(marker) {
      var info_window;
      info_window = jQuery(_map.map).data("info-window");
      if (__duplicate_marker_map[jQuery(marker).data("key")].length > 1) {
        return info_window.open_multiple(__duplicate_marker_map[jQuery(marker).data("key")]);
      } else {
        return info_window.open_single(marker);
      }
    },
    target: function(marker_data) {
      if (marker_data.post_type.split(":")[0] === "inat") {
        return "_blank";
      }
    },
    icon: function(marker_data) {
      var default_icon;
      default_icon = "/wp-content/plugins/trailfinder/images/trail.png";
      return {
        inat: "/wp-content/plugins/trailfinder/images/inat.png",
        article: "/wp-content/plugins/trailfinder/images/event.png",
        park: "/wp-content/plugins/trailfinder/images/park.png",
        trailhead: "/wp-content/plugins/trailfinder/images/trailhead.png",
        tribe_events: "/wp-content/plugins/trailfinder/images/event.png"
      }[marker_data.post_type.split(":")[0]] || default_icon;
    },
    display: function(marker) {
      var data, key;
      if (!_map.options.focus) {
        return true;
      }
      data = jQuery(marker).data("marker_data");
      key = jQuery(marker).data("key");
      if (_map.focus_data.ID === data.ID) {
        return true;
      }
      if (_map.focus_key === key) {
        return false;
      }
      return true;
    },
    extend_bounds: function(marker) {
      var data;
      data = jQuery(marker).data("marker_data");
      if (data.post_type === "inat:observation" || data.post_type === "tribe_events") {
        return false;
      }
      return true;
    },
    use_clusterer: function(marker) {
      var data;
      data = jQuery(marker).data("marker_data");
      if (data.post_type === "inat:observation" || data.post_type === "tribe_events") {
        return false;
      } else if (data.ID === _map.options.focus) {
        return false;
      }
      return true;
    }
  };

  blank_location = function(data) {
    try {
      return !parseFloat(data.latitude[0]) || !parseFloat(data.longitude[0]);
    } catch (e) {
      return true;
    }
  };

  window.DataSource = DataSource = (function() {

    function DataSource(url, options) {
      this._is_data_source = true;
      this.url = url;
      this.options = options;
      this.marker_data = null;
      this.markers = [];
      this.type_marker_map = {};
    }

    DataSource.prototype.add_marker = function(marker_data) {
      var icon, key, marker, marker_type, point;
      if (blank_location(marker_data)) {
        return;
      }
      key = "" + marker_data.latitude[0] + "-" + marker_data.longitude[0];
      point = new google.maps.LatLng(marker_data.latitude[0], marker_data.longitude[0]);
      marker_type = marker_data.post_type.split(":")[0];
      icon = Marker.icon(marker_data);
      marker_data.marker_icon = icon;
      marker_data.marker_type = marker_type;
      marker_data.target = Marker.target(marker_data);
      marker = new google.maps.Marker({
        position: point,
        draggable: false,
        icon: icon
      });
      (function(marker) {
        var _this = this;
        google.maps.event.addListener(marker, "click", (function(opts) {
          return Marker.click(marker);
        }));
        google.maps.event.addListener(marker, "mouseover", (function(opts) {
          return Marker.mouseover(marker);
        }));
        return google.maps.event.addListener(marker, "mouseout", (function(opts) {
          return Marker.mouseout(marker);
        }));
      })(marker);
      jQuery(marker).data("marker_data", marker_data);
      jQuery(marker).data("key", key);
      this.markers.push(marker);
      __type_marker_map[marker_type] || (__type_marker_map[marker_type] = []);
      __type_marker_map[marker_type].push(marker);
      __duplicate_marker_map[key] || (__duplicate_marker_map[key] = []);
      __duplicate_marker_map[key].push(marker);
      return __id_marker_map[marker_data.ID] = marker;
    };

    DataSource.prototype.load = function() {
      var dfd,
        _this = this;
      dfd = jQuery.Deferred();
      jQuery.getJSON(this.url, function(response) {
        var marker_data, _i, _len;
        if (response) {
          for (_i = 0, _len = response.length; _i < _len; _i++) {
            marker_data = response[_i];
            _this.add_marker(marker_data);
          }
        }
        jQuery(_this).trigger("loaded");
        return dfd.resolve();
      });
      return dfd.promise();
    };

    return DataSource;

  })();

  window.FlickrDataSource = FlickrDataSource = (function(_super) {

    __extends(FlickrDataSource, _super);

    function FlickrDataSource() {
      return FlickrDataSource.__super__.constructor.apply(this, arguments);
    }

    FlickrDataSource.prototype.load = function() {
      var dfd, options, url, _base, _ref,
        _this = this;
      if ((_ref = (_base = jQuery.flickr).settings) == null) {
        _base.settings = {
          api_key: FLICKR_KEY
        };
      }
      dfd = jQuery.Deferred();
      options = {
        user_id: "55143739@N03",
        extras: "description, license, date_upload, date_taken, owner_name, icon_server, original_format, last_update, geo, tags, machine_tags, o_dims, views, media, path_alias, url_sq, url_t, url_s, url_q, url_m, url_n, url_z, url_c, url_l, url_o",
        has_geo: "1"
      };
      if (this.options.latitude && this.options.longitude) {
        jQuery.extend(options, {
          lat: this.options.latitude,
          lon: this.options.longitude,
          radius: 20
        });
      }
      url = jQuery.flickr.url("flickr.photos.search", options);
      jQuery.getJSON(url, function(response) {
        var marker_data, photo, _i, _len, _ref1;
        if ((response.photos.total * 1) > 0) {
          _ref1 = response.photos.photo;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            photo = _ref1[_i];
            marker_data = jQuery.extend({
              post_type: "flickr",
              post_content: photo.description
            }, photo);
            _this.add_marker(marker_data);
          }
        }
        return dfd.resolve();
      });
      return dfd.promise();
    };

    return FlickrDataSource;

  })(DataSource);

  PostTypeControl = (function() {

    function PostTypeControl(element, map) {
      var _this = this;
      this.element = element;
      this.map = map;
      this.type = jQuery("._post_type", element).text().trim();
      this.toggle = jQuery(".toggle input", element);
      this.enabled = true;
      jQuery(map).bind("markers-loaded", function() {
        if (__type_marker_map[_this.type]) {
          return jQuery(".count", element).html(__type_marker_map[_this.type].length);
        }
      });
      if (this.toggle.length > 0) {
        this.toggle.click(function() {
          return _this.toggled();
        });
        jQuery(map).bind("markers-loaded", function() {
          if (!_this.toggle.attr("checked")) {
            return _this.toggled();
          }
        });
      }
    }

    PostTypeControl.prototype.toggled = function(ev) {
      var _this = this;
      if (ev == null) {
        ev = null;
      }
      this.map.begin_filter_hook();
      if (this.filter) {
        this.map.remove_filter(this.filter);
      }
      if (this.toggle.attr("checked")) {
        this.filter = this.map.filter(function(marker) {
          return jQuery(marker).data("marker_data").marker_type === _this.type;
        });
        jQuery(this.element).trigger("activated");
      } else {
        this.filter = this.map.filter(function(marker) {
          return jQuery(marker).data("marker_data").marker_type !== _this.type;
        });
        jQuery(this.element).trigger("deactivated");
      }
      return this.map.end_filter_hook();
    };

    return PostTypeControl;

  })();

  window.FilterControl = FilterControl = (function() {

    function FilterControl(element, map, filter) {
      var _this = this;
      this.element = jQuery(element);
      this.map = map;
      if (!this.filter) {
        this.filter = filter;
      }
      jQuery(this.map).bind("markers-loaded", function() {
        return _this.changed();
      });
      this.element.change(function() {
        return _this.changed();
      });
    }

    FilterControl.prototype.changed = function() {
      var activated;
      activated = this.is_activated();
      this.apply_filter(activated);
      if (activated) {
        return this.element.trigger("activated");
      } else {
        return this.element.trigger("deactivated");
      }
    };

    FilterControl.prototype.is_activated = function() {
      if (this.element.attr("type") === "checkbox") {
        return this.element.is(":checked");
      } else {
        return this.element.val() && this.element.val() !== "false" && this.element.val() !== "";
      }
    };

    FilterControl.prototype.apply_filter = function(activated) {
      this.map.begin_filter_hook();
      if (this._filter) {
        this.map.remove_filter(this._filter);
      }
      if (activated) {
        this.name = this.element.attr("name");
        this.value = this.element.val();
        this._filter = this.map.filter(this.filter.bind(this));
      }
      return this.map.end_filter_hook();
    };

    return FilterControl;

  })();

  window.MatchFilterControl = MatchFilterControl = (function(_super) {

    __extends(MatchFilterControl, _super);

    function MatchFilterControl() {
      this.filter = __bind(this.filter, this);
      return MatchFilterControl.__super__.constructor.apply(this, arguments);
    }

    MatchFilterControl.prototype.filter = function(marker) {
      var data;
      data = jQuery(marker).data("marker_data");
      if (data.post_type === "inat:observation" || data.post_type === "tribe_events") {
        return true;
      }
      return data[this.name] === this.value;
    };

    return MatchFilterControl;

  })(FilterControl);

  window.ActivationFilterControl = ActivationFilterControl = (function(_super) {

    __extends(ActivationFilterControl, _super);

    function ActivationFilterControl(element, map, filter) {
      this.filter = __bind(this.filter, this);

      var _this = this;
      ActivationFilterControl.__super__.constructor.call(this, element, map, filter);
      jQuery("a.toggle", this.element.parent()).click(function() {
        _this.element.trigger("click");
        return false;
      });
    }

    ActivationFilterControl.prototype.is_activated = function() {
      this.checked = this.element.attr("checked") !== void 0;
      if (this.checked) {
        jQuery("a.toggle", this.element.parent()).addClass("on").removeClass("off");
      } else {
        jQuery("a.toggle", this.element.parent()).addClass("off").removeClass("on");
      }
      return true;
    };

    ActivationFilterControl.prototype.filter = function(marker) {
      if (this.checked) {
        return true;
      }
      if (jQuery(marker).data("marker_data")[this.name] === this.value) {
        return false;
      } else {
        return true;
      }
    };

    return ActivationFilterControl;

  })(FilterControl);

  window.IncludeFilterControl = IncludeFilterControl = (function(_super) {

    __extends(IncludeFilterControl, _super);

    function IncludeFilterControl() {
      this.filter = __bind(this.filter, this);
      return IncludeFilterControl.__super__.constructor.apply(this, arguments);
    }

    IncludeFilterControl.prototype.filter = function(marker) {
      var data, possibility, _i, _len, _ref;
      data = jQuery(marker).data("marker_data");
      if (data.post_type === "inat:observation" || data.post_type === "tribe_events") {
        return true;
      }
      try {
        _ref = data[this.name];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          possibility = _ref[_i];
          if (possibility === this.value) {
            return true;
          }
        }
      } catch (error) {
        return false;
      }
      return false;
    };

    return IncludeFilterControl;

  })(FilterControl);

  __filter_index = 999;

  Filter = (function() {

    function Filter(cb) {
      this.condition = cb;
      this.__id = __filter_index++;
    }

    return Filter;

  })();

  Map = (function() {

    function Map(element, options) {
      this.initialize_counts = __bind(this.initialize_counts, this);

      this.initialize_markers = __bind(this.initialize_markers, this);

      var _this = this;
      window._map = this;
      this.element = element;
      this.sources = options.sources;
      this.clusterer = null;
      this.options = options;
      this.tasks = {};
      this.filters = [];
      this.__filtering = 0;
      jQuery(this).bind("sources-loaded", function() {
        _this.focus = __id_marker_map[_this.options.focus];
        _this.focus_data = jQuery(_this.focus).data("marker_data");
        _this.focus_key = jQuery(_this.focus).data("key");
        _this.initialize_counts();
        return _this.initialize_markers();
      });
      jQuery(this).bind("markers-loaded", function() {
        _this.initialize_clusterer();
        if (_this.options.focus) {
          return Marker.focus(_this, __id_marker_map[_this.options.focus]);
        }
      });
      this.initialize_map();
      this.initialize_info_window();
      this.initialize_hover_window();
      this.initialize_sources();
      jQuery(document).trigger("map-initializing", this);
    }

    Map.prototype.mark_task = function(task) {
      this.tasks[task] = true;
      if (this.options.mask_element) {
        return jQuery(this.options.mask_element).mask("Loading...");
      }
    };

    Map.prototype.clear_task = function(task) {
      var k, v, _ref;
      delete this.tasks[task];
      _ref = this.tasks;
      for (k in _ref) {
        v = _ref[k];
        if (v) {
          return;
        }
      }
      if (this.options.mask_element) {
        return jQuery(this.options.mask_element).unmask();
      }
    };

    Map.prototype.register_results_panel = function(target, template, filter, once) {
      var rendered;
      if (once == null) {
        once = false;
      }
      template = jQuery(template).text();
      rendered = false;
      jQuery(this).unbind("markers-drawn.results");
      return jQuery(this).bind("markers-drawn.results", function() {
        var marker, marker_data, markers, _i, _len, _ref;
        if (rendered && once) {
          return;
        }
        markers = [];
        _ref = this.markers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          marker = _ref[_i];
          marker_data = jQuery(marker).data("marker_data");
          if (filter(marker, marker_data)) {
            markers.push(marker_data);
          }
        }
        markers.sort(function(a, b) {
          if (a.post_title > b.post_title) {
            return 1;
          } else if (a.post_title < b.post_title) {
            return -1;
          } else {
            return 0;
          }
        });
        jQuery(target).html(Mustache.render(template, {
          markers: markers
        }));
        return rendered = true;
      });
    };

    Map.prototype.select_focus = function(fn) {
      var data, marker, _i, _len, _ref;
      _ref = this.markers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
        data = jQuery(marker).data("marker_data");
        if (fn(marker, data)) {
          Marker.click(marker);
          return;
        }
      }
    };

    Map.prototype.update_sources = function(sources, center) {
      var _this = this;
      if (center == null) {
        center = false;
      }
      __duplicate_marker_map = {};
      __type_marker_map = {};
      __id_marker_map = {};
      this.sources = sources;
      this.initialize_sources();
      jQuery(this).unbind("clusterer-loaded.update_sources");
      jQuery(this).bind("clusterer-loaded.update_sources", function() {
        return _this.reload();
      });
      jQuery(this).unbind("markers-drawn.update_sources");
      return jQuery(this).bind("markers-drawn.update_sources", function(ev, markers) {
        if (markers.length > 0) {
          return _this.map.fitBounds(_this.bounds);
        }
      });
    };

    Map.prototype.initialize_map = function() {
      var image_map, options, route;
      this.mark_task("Initializing Map");
      options = {
        zoom: 9,
        mapTypeId: google.maps.MapTypeId.ROADMAP,
        scrollwheel: false,
        mapTypeControlOptions: {
          mapTypeIds: [google.maps.MapTypeId.ROADMAP, "Parks", google.maps.MapTypeId.HYBRID]
          //mapTypeIds: [google.maps.MapTypeId.ROADMAP, "Map", google.maps.MapTypeId.HYBRID]
        }
      };
      if (this.options.center) {
        options.center = new google.maps.LatLng(this.options.center.latitude, this.options.center.longitude);
      }
      this.map = new google.maps.Map(this.element, options);
      if (this.options.bounds) {
        this.map.fitBounds(this.options.bounds);
      }
      image_map = new google.maps.ImageMapType({
        getTileUrl: function(coord, zoom) {
          return "http://tilestache.greeninfo.org/tilestache/tilestache.py/parkinfo_withlabels" + "/" + zoom + "/" + coord.x + "/" + coord.y + ".jpg";
        },
        tileSize: new google.maps.Size(256, 256),
        isPng: false,
        maxZoom: 16,
        minZoom: 0,
        name: "Parks"
      });
      if (this.options.route) {
        route = new google.maps.Polyline({
          geodesic: true,
          clickable: false,
          strokeColor: "#F42F0D",
          strokeOpacity: 0.8,
          editable: false,
          path: this.options.route,
          map: this.map
        });
      }
      this.map.mapTypes.set("Parks", image_map);
     // this.map.setMapTypeId("Parks");
     // this.map.setMapTypeId("Map");
      return this.clear_task("Initializing Map");
    };

    Map.prototype.initialize_hover_window = function() {
      this.hover_window = new InfoWindow({
        map: this.map,
        content: '<div></div>',
        shadowStyle: 1,
        padding: 2,
        backgroundColor: '#F7F7F7',
        borderRadius: 4,
        arrowSize: 10,
        borderWidth: 1,
        borderColor: '#CCCCCC',
        disableAutoPan: true,
        hideCloseButton: true,
        arrowPosition: 30,
        backgroundClassName: 'info-background',
        arrowStyle: 2,
        zIndex: 50
      });
      return jQuery(this.map).data("hover-window", this.hover_window);
    };

    Map.prototype.initialize_info_window = function() {
      var _this = this;
      this.mark_task("Initializing Info Window");
      this.info_window = new InfoWindow({
        map: this.map,
        content: '<div class="info" id="label">Test</div>',
        shadowStyle: 1,
        padding: 2,
        backgroundColor: '#F7F7F7',
        borderRadius: 4,
        arrowSize: 10,
        borderWidth: 1,
        borderColor: '#CCCCCC',
        disableAutoPan: false,
        hideCloseButton: false,
        arrowPosition: 30,
        backgroundClassName: 'info-background',
        arrowStyle: 2
      });
      jQuery(this.map).data("info-window", this.info_window);
      google.maps.event.addListener(this.map, "zoom_changed", (function() {
        return _this.info_window.close();
      }));
      google.maps.event.addListener(this.map, "click", (function() {
        return _this.info_window.close();
      }));
      return this.clear_task("Initializing Info Window");
    };

    Map.prototype.initialize_sources = function() {
      var dfds, source, _i, _len, _ref,
        _this = this;
      this.mark_task("Initializing Sources");
      dfds = [];
      this.sources = jQuery(this.sources).map(function() {
        if (this._is_data_source) {
          return this;
        } else {
          return new DataSource(this);
        }
      });
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        dfds.push(source.load());
      }
      return jQuery.when.apply(this, dfds).then(function() {
        _this.clear_task("Initializing Sources");
        return jQuery(_this).trigger("sources-loaded");
      });
    };

    Map.prototype.initialize_markers = function() {
      var source, _i, _len, _ref;
      this.mark_task("Initializing Markers");
      this.markers = [];
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        this.markers = this.markers.concat(source.markers);
      }
      this._markers = this.markers;
      this.clear_task("Initializing Markers");
      if (this.options.autoselect) {
        Marker.click(__id_marker_map[this.options.autoselect]);
      }
      this.begin_filter_hook();
      jQuery(this).trigger("markers-loaded");
      return this.end_filter_hook();
    };

    Map.prototype.initialize_counts = function() {
      var count, count_element, type, _i, _len, _ref, _results;
      _ref = jQuery(".post-count");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        count_element = _ref[_i];
        type = jQuery(".type", count_element).html();
        if (__type_marker_map[type]) {
          count = __type_marker_map[type].length;
        } else {
          count = 0;
        }
        _results.push(jQuery(".value", count_element).html(count));
      }
      return _results;
    };

    Map.prototype.initialize_clusterer = function() {
      var _this = this;
      if (!this.options.clusterer) {
        return;
      }
      this.mark_task("Initializing Clusterer");
      if (!this.clusterer) {
        this.clusterer = new MarkerClusterer(this.map, [], {
          gridSize: 50,
          maxZoom: 15,
          minimumClusterSize: 5,
          imagePath: "/wp-content/plugins/trailfinder/images/cluster/m"
        });
        google.maps.event.addListener(this.clusterer, "click", function() {
          var bounds;
          bounds = _this.map.getBounds();
          if (bounds.getNorthEast().equals(bounds.getSouthWest())) {
            _this.clusterer.zoomOnClick_ = false;
            return renderMarkers(_this.clusterer.getMarkers());
          }
        });
      }
      this.reload_clusterer();
      this.clear_task("Initializing Clusterer");
      return jQuery(this).trigger("clusterer-loaded");
    };

    Map.prototype.reload_clusterer = function(markers) {
      var cluster_markers, marker, standalone_markers, _i, _j, _len, _len1, _ref;
      if (markers == null) {
        markers = null;
      }
      if (this.__filtering > 0) {
        return;
      }
      markers || (markers = this._markers);
      this.markers = markers;
      this.__standalone_markers || (this.__standalone_markers = []);
      _ref = this.__standalone_markers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
        marker.setMap(null);
        Marker.map_set(null, marker);
      }
      cluster_markers = [];
      standalone_markers = [];
      this.bounds = new google.maps.LatLngBounds();
      for (_j = 0, _len1 = markers.length; _j < _len1; _j++) {
        marker = markers[_j];
        if (Marker.extend_bounds(marker)) {
          this.bounds.extend(marker.getPosition());
        }
        if (Marker.display(marker)) {
          if (Marker.use_clusterer(marker)) {
            cluster_markers.push(marker);
          } else {
            standalone_markers.push(marker);
            marker.setMap(this.map);
          }
          Marker.map_set(this.map, marker);
        }
      }
      this.__standalone_markers = standalone_markers;
      this.clusterer.clearMarkers();
      this.clusterer.addMarkers(cluster_markers);
      return jQuery(this).trigger("markers-drawn", [this.markers]);
    };

    Map.prototype.begin_filter_hook = function() {
      this.__filtering += 1;
      if (this.__filtering === 1) {
        this.__filters_added = [];
        this.__filters_removed = [];
        return this.__filter_marker_buffer = this.markers;
      }
    };

    Map.prototype.end_filter_hook = function() {
      this.__filtering -= 1;
      if (this.__filtering < 0) {
        this.__filtering = 0;
      }
      if (this.__filtering !== 0) {
        return;
      }
      if (this.__filters_added.length && !this.__filters_removed.length) {
        return this.reload_clusterer(this.__filter_marker_buffer);
      } else if (this.__filters_removed.length) {
        return this.reload();
      }
    };

    Map.prototype.filter = function(cb, application) {
      var filter, marker, markers, _filter_ids, _i, _len, _markers;
      if (application == null) {
        application = true;
      }
      this.info_window.close();
      this.mark_task("Filtering");
      if (this.__filtering > 0) {
        markers = this.__filter_marker_buffer;
      } else {
        if (application) {
          markers = this.markers;
        } else {
          markers = this._markers;
        }
      }
      _markers = [];
      _filter_ids = [];
      filter = new Filter(cb);
      this.filters.push(filter);
      if (this.__filtering > 0) {
        this.__filters_added.push(filter);
      }
      for (_i = 0, _len = markers.length; _i < _len; _i++) {
        marker = markers[_i];
        if (filter.condition(marker)) {
          _markers.push(marker);
        }
      }
      jQuery(filter).trigger("executed");
      _filter_ids.push(filter.__id);
      if (this.__filtering > 0) {
        this.__filter_marker_buffer = _markers;
      } else {
        if (application) {
          this.reload_clusterer(_markers);
        }
      }
      this.clear_task("Filtering");
      return filter.__id;
    };

    Map.prototype.remove_filter = function(id) {
      var filter, _filters, _i, _len, _ref;
      this.info_window.close();
      if (this.__filtering > 0) {
        this.__filters_removed.push(id);
      }
      _filters = [];
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filter = _ref[_i];
        if (id !== filter.__id) {
          _filters.push(filter);
        }
      }
      this.filters = _filters;
      this.markers = this._markers;
      return this.reload();
    };

    Map.prototype.reload = function() {
      var filter, marker, _i, _j, _len, _len1, _markers, _markers_tmp, _ref;
      if (this.__filtering > 0) {
        return;
      }
      this.info_window.close();
      this.mark_task("Reloading");
      _markers = this.markers.slice(0);
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filter = _ref[_i];
        _markers_tmp = [];
        for (_j = 0, _len1 = _markers.length; _j < _len1; _j++) {
          marker = _markers[_j];
          if (filter.condition(marker)) {
            _markers_tmp.push(marker);
          }
        }
        jQuery(filter).trigger("executed");
        _markers = _markers_tmp;
      }
      this.clear_task("Reloading");
      return this.reload_clusterer(_markers);
    };

    return Map;

  })();

  window.trailfinder = function(element, sources, options) {
    var bounds, latlng, latlngs, map, message, point, _i, _len, _ref;
    options || (options = {});
    options.info_window || (options.info_window = true);
    options.hover_window || (options.hover_window = true);
    options.clusterer || (options.clusterer = true);
    options.sources = sources;
    if (options.route) {
      latlngs = [];
      bounds = new google.maps.LatLngBounds();
      _ref = options.route;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        latlng = new google.maps.LatLng(point[0], point[1]);
        latlngs.push(latlng);
        bounds.extend(latlng);
      }
      options.bounds = bounds;
      options.route = latlngs;
    }
    map = new Map(jQuery(".map-canvas", element)[0], options);
    jQuery(".post-type-control", element).each(function() {
      return new PostTypeControl(this, map);
    });
    jQuery(".info-window-toggle").each(function() {
      var post_id;
      post_id = jQuery(this).attr("href").slice(1);
      return jQuery(this).click(function() {
        if (__id_marker_map[post_id]) {
          return Marker.click(__id_marker_map[post_id]);
        }
      });
    });
    jQuery(map).bind("markers-loaded", function() {
      var ids, k, v;
      ids = [];
      for (k in __id_marker_map) {
        v = __id_marker_map[k];
        ids.push(k);
      }
      return jQuery("#trailfinder-results").load("/wp-content/plugins/trailfinder/_partial_items.php", {
        post_ids: ids
      }, function() {
        return jQuery(".info-window-toggle", jQuery("#trailfinder-results")).each(function() {
          var post_id;
          post_id = jQuery(this).attr("href").slice(1);
          return jQuery(this).click(function() {
            if (__id_marker_map[post_id]) {
              return Marker.click(__id_marker_map[post_id]);
            }
          });
        });
      });
    });
    message = null;
    jQuery(map).bind("markers-drawn", function(ev, markers) {
      if (markers.length === 0) {
        if (message) {
          return;
        }
        return message = jQuery().toastmessage('showToast', {
          text: "No results found matching your criteria!",
          position: "middle-center",
          type: "warning",
          close: function() {
            return message = false;
          }
        });
      }
    });
    jQuery(".trailfinder-results");
    jQuery(map).bind("loaded", function() {
      return jQuery(document).trigger("trailfinder-initialized");
    });
    return map;
  };

  jQuery(document).trigger("trailfinder-loaded");

}).call(this);
